-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParTreeSitter
  ( happyError
  , myLexer
  , pGrammar
  , pPreamble
  , pConstDecl
  , pListConstDecl
  , pGrammarBody
  , pName
  , pRules
  , pRule
  , pListRule
  ) where

import Prelude

import qualified AbsTreeSitter
import LexTreeSitter

}

%name pGrammar Grammar
%name pPreamble Preamble
%name pConstDecl ConstDecl
%name pListConstDecl ListConstDecl
%name pGrammarBody GrammarBody
%name pName Name
%name pRules Rules
%name pRule Rule
%name pListRule ListRule
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '$'         { PT _ (TS _ 1)  }
  '('         { PT _ (TS _ 2)  }
  ')'         { PT _ (TS _ 3)  }
  ','         { PT _ (TS _ 4)  }
  '.'         { PT _ (TS _ 5)  }
  ':'         { PT _ (TS _ 6)  }
  ';'         { PT _ (TS _ 7)  }
  '='         { PT _ (TS _ 8)  }
  '=>'        { PT _ (TS _ 9)  }
  'RustRegex' { PT _ (TS _ 10) }
  'choice'    { PT _ (TS _ 11) }
  'const'     { PT _ (TS _ 12) }
  'exports'   { PT _ (TS _ 13) }
  'grammar'   { PT _ (TS _ 14) }
  'module'    { PT _ (TS _ 15) }
  'name'      { PT _ (TS _ 16) }
  'new'       { PT _ (TS _ 17) }
  'optional'  { PT _ (TS _ 18) }
  'repeat'    { PT _ (TS _ 19) }
  'repeat1'   { PT _ (TS _ 20) }
  'rules'     { PT _ (TS _ 21) }
  'seq'       { PT _ (TS _ 22) }
  '{'         { PT _ (TS _ 23) }
  '}'         { PT _ (TS _ 24) }
  L_quoted    { PT _ (TL $$)   }
  L_Id        { PT _ (T_Id $$) }

%%

String  :: { String }
String   : L_quoted { $1 }

Id :: { AbsTreeSitter.Id }
Id  : L_Id { AbsTreeSitter.Id $1 }

Grammar :: { AbsTreeSitter.Grammar }
Grammar
  : Preamble 'module' '.' 'exports' '=' 'grammar' '(' '{' GrammarBody '}' ')' ';' { AbsTreeSitter.Grammar $1 $9 }

Preamble :: { AbsTreeSitter.Preamble }
Preamble : ListConstDecl { AbsTreeSitter.Preamble $1 }

ConstDecl :: { AbsTreeSitter.ConstDecl }
ConstDecl : 'const' Id '=' String { AbsTreeSitter.ConstDecl $2 $4 }

ListConstDecl :: { [AbsTreeSitter.ConstDecl] }
ListConstDecl
  : {- empty -} { [] } | ConstDecl ';' ListConstDecl { (:) $1 $3 }

GrammarBody :: { AbsTreeSitter.GrammarBody }
GrammarBody
  : Name ',' Rules ',' { AbsTreeSitter.GrammarBody $1 $3 }

Name :: { AbsTreeSitter.Name }
Name : 'name' ':' String { AbsTreeSitter.Name $3 }

Rules :: { AbsTreeSitter.Rules }
Rules : 'rules' ':' '{' ListRule '}' { AbsTreeSitter.Rules $4 }

Rule :: { AbsTreeSitter.Rule }
Rule
  : Id ':' '$' '=>' Rule { AbsTreeSitter.Rule $1 $5 }
  | 'choice' '(' ListRule ')' { AbsTreeSitter.Choice $3 }
  | 'seq' '(' ListRule ')' { AbsTreeSitter.Seq $3 }
  | 'repeat' '(' Rule ')' { AbsTreeSitter.Repeat $3 }
  | 'repeat1' '(' Rule ')' { AbsTreeSitter.Repeat1 $3 }
  | 'optional' '(' Rule ')' { AbsTreeSitter.Optional $3 }
  | '$' '.' Id { AbsTreeSitter.Symbol $3 }
  | Id { AbsTreeSitter.Const $1 }
  | String { AbsTreeSitter.Literal $1 }
  | 'new' 'RustRegex' '(' String ')' { AbsTreeSitter.Regex $4 }

ListRule :: { [AbsTreeSitter.Rule] }
ListRule
  : {- empty -} { [] }
  | Rule ',' ListRule { (:) $1 $3 }
  | {- empty -} { [] }
  | Rule { (:[]) $1 }
  | Rule ',' ListRule { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

