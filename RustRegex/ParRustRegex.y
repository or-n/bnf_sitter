-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParRustRegex
  ( happyError
  , myLexer
  , pGrammar
  , pClass
  , pListClass
  , pConcat
  , pListConcat
  , pCharacter
  , pRepeat
  , pEmpty
  , pMyChar
  ) where

import Prelude

import qualified AbsRustRegex
import LexRustRegex

}

%name pGrammar Grammar
%name pClass Class
%name pListClass ListClass
%name pConcat Concat
%name pListConcat ListConcat
%name pCharacter Character
%name pRepeat Repeat
%name pEmpty Empty
%name pMyChar MyChar
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '\"'         { PT _ (TS _ 1)      }
  '$'          { PT _ (TS _ 2)      }
  '&&'         { PT _ (TS _ 3)      }
  '('          { PT _ (TS _ 4)      }
  ')'          { PT _ (TS _ 5)      }
  '*'          { PT _ (TS _ 6)      }
  '*?'         { PT _ (TS _ 7)      }
  '+'          { PT _ (TS _ 8)      }
  '+?'         { PT _ (TS _ 9)      }
  ','          { PT _ (TS _ 10)     }
  '-'          { PT _ (TS _ 11)     }
  '--'         { PT _ (TS _ 12)     }
  '.'          { PT _ (TS _ 13)     }
  '?'          { PT _ (TS _ 14)     }
  '??'         { PT _ (TS _ 15)     }
  'A'          { PT _ (TS _ 16)     }
  'B'          { PT _ (TS _ 17)     }
  '['          { PT _ (TS _ 18)     }
  '[:^alpha:]' { PT _ (TS _ 19)     }
  '[:alpha:]'  { PT _ (TS _ 20)     }
  '\\'         { PT _ (TS _ 21)     }
  '\\D'        { PT _ (TS _ 22)     }
  '\\P'        { PT _ (TS _ 23)     }
  '\\PN'       { PT _ (TS _ 24)     }
  '\\d'        { PT _ (TS _ 25)     }
  '\\p'        { PT _ (TS _ 26)     }
  '\\pN'       { PT _ (TS _ 27)     }
  ']'          { PT _ (TS _ 28)     }
  '^'          { PT _ (TS _ 29)     }
  'b'          { PT _ (TS _ 30)     }
  'z'          { PT _ (TS _ 31)     }
  '{'          { PT _ (TS _ 32)     }
  '|'          { PT _ (TS _ 33)     }
  '}'          { PT _ (TS _ 34)     }
  '~~'         { PT _ (TS _ 35)     }
  L_charac     { PT _ (TC $$)       }
  L_Number     { PT _ (T_Number $$) }
  L_Name       { PT _ (T_Name $$)   }

%%

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Number :: { AbsRustRegex.Number }
Number  : L_Number { AbsRustRegex.Number $1 }

Name :: { AbsRustRegex.Name }
Name  : L_Name { AbsRustRegex.Name $1 }

Grammar :: { AbsRustRegex.Grammar }
Grammar
  : Concat { AbsRustRegex.ConcatGrammar $1 }
  | '[' Class ']' Repeat { AbsRustRegex.Class $2 $4 }
  | Grammar '|' Grammar { AbsRustRegex.Alt $1 $3 }
  | '(' Grammar ')' Repeat { AbsRustRegex.Group $2 $4 }

Class :: { AbsRustRegex.Class }
Class
  : Concat { AbsRustRegex.ConcatClass $1 }
  | ListClass { AbsRustRegex.Seq $1 }
  | '^' ListClass { AbsRustRegex.Except $2 }
  | Char '-' Char { AbsRustRegex.Range $1 $3 }
  | '[:alpha:]' { AbsRustRegex.Ascii }
  | '[:^alpha:]' { AbsRustRegex.NotAscii }
  | Class '&&' Class { AbsRustRegex.Intersect $1 $3 }
  | Class '--' Class { AbsRustRegex.Subtract $1 $3 }
  | Class '~~' Class { AbsRustRegex.SymmetricDiff $1 $3 }
  | '[' Class ']' { AbsRustRegex.Nest $2 }

ListClass :: { [AbsRustRegex.Class] }
ListClass : {- empty -} { [] } | Class ListClass { (:) $1 $2 }

Concat :: { AbsRustRegex.Concat }
Concat
  : MyChar { AbsRustRegex.Char $1 }
  | '\\' MyChar { AbsRustRegex.Escape $2 }
  | Character { AbsRustRegex.Character $1 }

ListConcat :: { [AbsRustRegex.Concat] }
ListConcat : {- empty -} { [] } | Concat ListConcat { (:) $1 $2 }

Character :: { AbsRustRegex.Character }
Character
  : '.' { AbsRustRegex.AnyExceptNewline }
  | '\\d' { AbsRustRegex.Digit }
  | '\\D' { AbsRustRegex.NotDigit }
  | '\\pN' { AbsRustRegex.UnicodeLetter }
  | '\\PN' { AbsRustRegex.NotUnicodeLetter }
  | '\\p' '{' Name '}' { AbsRustRegex.LetterClass $3 }
  | '\\P' '{' Name '}' { AbsRustRegex.NotLetterClass $3 }

Repeat :: { AbsRustRegex.Repeat }
Repeat
  : '*' { AbsRustRegex.Many }
  | '+' { AbsRustRegex.Some }
  | '?' { AbsRustRegex.Optional }
  | '*?' { AbsRustRegex.ManyLazy }
  | '+?' { AbsRustRegex.SomeLazy }
  | '??' { AbsRustRegex.OptionalLazy }
  | '{' Number ',' Number '}' { AbsRustRegex.LeastMost $2 $4 }
  | '{' Number ',' '}' { AbsRustRegex.Least $2 }
  | '{' Number '}' { AbsRustRegex.Exactly $2 }
  | '{' Number ',' Number '}' '?' { AbsRustRegex.LeastMostLazy $2 $4 }
  | '{' Number ',' '}' '?' { AbsRustRegex.LeastLazy $2 }
  | '{' Number '}' '?' { AbsRustRegex.ExactlyLazy $2 }
  | {- empty -} { AbsRustRegex.No }

Empty :: { AbsRustRegex.Empty }
Empty
  : '^' { AbsRustRegex.Start }
  | '$' { AbsRustRegex.End }
  | 'A' { AbsRustRegex.OnlyStart }
  | 'z' { AbsRustRegex.OnlyEnd }
  | 'b' { AbsRustRegex.UnicodeBoundary }
  | 'B' { AbsRustRegex.NotUnicodeBoundary }

MyChar :: { AbsRustRegex.MyChar }
MyChar
  : '\"' { AbsRustRegex.Quote }
  | '\\' { AbsRustRegex.EscapeChar }
  | Char { AbsRustRegex.Other $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

