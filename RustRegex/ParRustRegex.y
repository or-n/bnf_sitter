-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParRustRegex
  ( happyError
  , myLexer
  , pRustRegexGrammar
  ) where

import Prelude

import qualified AbsRustRegex
import LexRustRegex

}

%name pRustRegexGrammar RustRegexGrammar
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '&&'         { PT _ (TS _ 1)    }
  '-'          { PT _ (TS _ 2)    }
  '--'         { PT _ (TS _ 3)    }
  '.'          { PT _ (TS _ 4)    }
  '['          { PT _ (TS _ 5)    }
  '[:^alpha:]' { PT _ (TS _ 6)    }
  '[:alpha:]'  { PT _ (TS _ 7)    }
  '\\'         { PT _ (TS _ 8)    }
  '\\D'        { PT _ (TS _ 9)    }
  '\\P'        { PT _ (TS _ 10)   }
  '\\PN'       { PT _ (TS _ 11)   }
  '\\d'        { PT _ (TS _ 12)   }
  '\\p'        { PT _ (TS _ 13)   }
  '\\pN'       { PT _ (TS _ 14)   }
  ']'          { PT _ (TS _ 15)   }
  '^'          { PT _ (TS _ 16)   }
  '{'          { PT _ (TS _ 17)   }
  '|'          { PT _ (TS _ 18)   }
  '}'          { PT _ (TS _ 19)   }
  '~~'         { PT _ (TS _ 20)   }
  L_charac     { PT _ (TC $$)     }
  L_Name       { PT _ (T_Name $$) }

%%

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Name :: { AbsRustRegex.Name }
Name  : L_Name { AbsRustRegex.Name $1 }

RustRegexGrammar :: { AbsRustRegex.RustRegexGrammar }
RustRegexGrammar
  : '[' Class ']' { AbsRustRegex.Class $2 }
  | Class '|' Class { AbsRustRegex.Alt $1 $3 }

Class :: { AbsRustRegex.Class }
Class
  : Char { AbsRustRegex.Char $1 }
  | ListClass { AbsRustRegex.Seq $1 }
  | '^' ListClass { AbsRustRegex.Except $2 }
  | Char '-' Char { AbsRustRegex.Range $1 $3 }
  | '[:alpha:]' { AbsRustRegex.Ascii }
  | '[:^alpha:]' { AbsRustRegex.NotAscii }
  | Class '&&' Class { AbsRustRegex.Intersect $1 $3 }
  | Class '--' Class { AbsRustRegex.Subtract $1 $3 }
  | Class '~~' Class { AbsRustRegex.SymmetricDiff $1 $3 }
  | '\\' Char { AbsRustRegex.Escape $2 }
  | '[' Class ']' { AbsRustRegex.Nest $2 }

ListClass :: { [AbsRustRegex.Class] }
ListClass : {- empty -} { [] } | Class ListClass { (:) $1 $2 }

Character :: { AbsRustRegex.Character }
Character
  : '.' { AbsRustRegex.AnyExceptNewline }
  | '\\d' { AbsRustRegex.Digit }
  | '\\D' { AbsRustRegex.NotDigit }
  | '\\pN' { AbsRustRegex.UnicodeLetter }
  | '\\PN' { AbsRustRegex.NotUnicodeLetter }
  | '\\p' '{' Name '}' { AbsRustRegex.LetterClass $3 }
  | '\\P' '{' Name '}' { AbsRustRegex.NotLetterClass $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

